<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="res/favicon.png" />
    <script src="res/dep/js/chart.min.js"></script>
    <script src="res/dep/js/chartjs-plugin-annotation.min.js"></script>
    <link rel="stylesheet" href="res/dep/css/materialize.min.css">
    <script src="res/dep/js/materialize.min.js"></script>
    <link href="res/dep/css/material-icon.css" rel="stylesheet">
    <link rel="stylesheet" href="res/dep/icn/weather-icons.css">
    <link rel="stylesheet" href="res/styles.css">
    <meta name="robots" content="noindex">
    <title>Météo</title>
  </head>
  <body>
    <menu>
      <a class="waves-effect waves-light btn modal-trigger" href="#modal">Changer les coordonnées</a>
    </menu>
    <div>
      <div id="modal" class="modal">
        <div class="modal-content">
          <h4>Coordonnées</h4>
          <div class="row">
            <div class="col s12">
              <div class="input-field col s12">
                <i class="material-icons prefix">search</i>
                <input type="text" id="autocomplete-input" class="autocomplete">
                <label for="autocomplete-input">Utiliser les coordonnées d'une ville</label>
              </div>
            </div>
          </div>
          <div class="row">
            <div class="col s12">
              <div class="input-field col s6">
                <i class="material-icons prefix">swap_vert</i>
                <input id="lat" type="text">
                <label for="lat">Latitude</label>
              </div>
              <div class="input-field col s6">
                <i class="material-icons prefix">swap_horiz</i>
                <input id="long" type="text">
                <label for="long">Longitude</label>
              </div>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <a class="waves-effect waves-light btn" id="btn_apply" onclick="citySelected()"><i class="material-icons right">keyboard_arrow_right</i>Appliquer</a>
        </div>
      </div>
    </div>
    <div>
      <div class="cont">
        <span id="loader" class="loader"></span>
        <canvas id="myChart" width="1440" height="800"></canvas>
      </div>
    </div>
  </body>
</html>
<script>

/*
** HashCode from Jericho Aquino (https://gist.github.com/eru123)
*/
const hashCode = (str) => str.split('').reduce((s, c) => Math.imul(31, s) + c.charCodeAt(0) | 0, 0);

let dictCoords = {};

window.addEventListener("load", function() {
  // erase inputs values
  document.querySelector('#autocomplete-input').value = '';
  document.querySelector('#lat').value = '';
  document.querySelector('#long').value = '';

  // bind the onchange trigger of the autocomplete to the onSelectCity() function
  document.querySelector('#autocomplete-input').addEventListener("change", (event) => {
    onSelectCity();
  });

  // bind inputs longitude and latitude with the correcting function
  document.querySelector('#lat').addEventListener("input", (event) => {
    checkLongLat(event);
  });
  document.querySelector('#long').addEventListener("input", (event) => {
    checkLongLat(event);
  });


  // load Json and fill autocomplete
  fetch('res/dat/cities.json')
    .then(response => {
      if (!response.ok) {
        throw new Error("HTTP error " + response.status);
      }
      return response.json();
    })
    .then(json => {
      let dictCities = {};

      json.forEach((item, index) => {
        let strElem = `${item['n']} (${item['c']})`;
        dictCities[strElem] = null;
        dictCoords[strElem] = [item['a'], item['o']];
      });

      var elems = document.querySelectorAll('.autocomplete');
      var instances = M.Autocomplete.init(elems, {
        data: dictCities,
        minLength: 3
      });
    })
    .catch(error => {
        console.error('Error: ', error);
    });

  // init modal
  var elems = document.querySelectorAll('.modal');
  var instances = M.Modal.init(elems, {dismissible:false});

  // force the user to choose a city
  // if there are no latitude and/or longitude params in the URL
  const urlParams = new URLSearchParams(window.location.search); 
  if (urlParams.get('lat') === null
  || urlParams.get('long') === null) {
    // open modal
    var instance = M.Modal.getInstance(elems[0]);
    instance.open();
  }
  else {
    let event = document.createEvent("Event");
    event.initEvent("focus", "onfocusin", true);
    
    let lat = document.querySelector('#lat');
    lat.value = urlParams.get('lat');
    lat.dispatchEvent(event);

    let long = document.querySelector('#long');
    long.value = urlParams.get('long');
    long.dispatchEvent(event);

    citySelected();
  }
});

function onSelectCity() {
  if (dictCoords[document.querySelector('#autocomplete-input').value] !== undefined) {
    let event = document.createEvent("Event");
    event.initEvent("focus", "onfocusin", true);

    let lat = document.querySelector('#lat');
    lat.value = dictCoords[document.querySelector('#autocomplete-input').value][0];
    lat.dispatchEvent(event);

    let long = document.querySelector('#long');
    long.value = dictCoords[document.querySelector('#autocomplete-input').value][1];
    long.dispatchEvent(event);
  }
}

function checkLongLat(_event) {
  _event.target.value = _event.target.value.replace(/[,]/g, '.').replace(/[.]/, '#').replace(/[^0-9-#]/g, '').replace(/[#]/, '.');
}

function isLongLatNum(_str) {
  return !isNaN(parseFloat(_str)) && isFinite(_str);
}

let bRunning = false
async function citySelected() {
  let lat = document.querySelector('#lat').value;
  let long = document.querySelector('#long').value;

  if (lat.length === 0) {
    M.toast({html: 'Latitude vide.'});
    return;
  }
  else if (long.length === 0) {
    M.toast({html: 'Longitude vide.'});
    return;
  }
  else if (parseFloat(lat) === NaN
  || isLongLatNum(lat) === false) {
    M.toast({html: 'Latitude incorrecte.'});
    return;
  }
  else if (parseFloat(long) === NaN
  || isLongLatNum(long) === false) {
    M.toast({html: 'Longitude incorrecte.'});
    return;
  }

  if (bRunning)
    return;
  else
    bRunning = true;

  document.getElementById('btn_apply').classList.add('disabled');

  // close modal
  M.Modal.getInstance(document.querySelectorAll('.modal')[0]).close();

  const nextURL = window.location.protocol + '//' + window.location.hostname + window.location.pathname + `?lat=${lat}&long=${long}`;
  const nextTitle = 'Meteo';
  const nextState = { additionalInformation: 'Meteo' };
  window.history.pushState(nextState, nextTitle, nextURL);

  if (myChart !== null)
    myChart.destroy();

  document.getElementById("loader").style.display = 'inline-block';

  let strTownHash = hashCode(`${lat},${long}`);
  let objLastRec = JSON.parse(localStorage.getItem(strTownHash));

  if (objLastRec === null
  || Date.now() - parseInt(objLastRec[0]) >= 0) {
    M.toast({html: 'Dernière mise à jour : maintenant'});
    const resWeather = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${long}&hourly=temperature_2m,precipitation,weathercode,cloudcover,windspeed_10m&daily=sunrise,sunset&timezone=Europe%2FParis`);
    let dataWeather = await resWeather.json();
    const resAir = await fetch(`https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${lat}&longitude=${long}&hourly=uv_index,carbon_monoxide,ozone,dust,pm10,pm2_5,alder_pollen,birch_pollen,grass_pollen,mugwort_pollen,olive_pollen,ragweed_pollen&timezone=Europe%2FParis`);
    let dataAir = await resAir.json();

    var arrData = [];
    arrData[0] = (Date.now() + 3.6e+6).toString();
    arrData[1] = dataWeather;
    arrData[2] = dataAir;
    localStorage.setItem(strTownHash, JSON.stringify(arrData));

    InitChar(arrData);
  }
  else {
    let deltaMs = Math.abs(Date.now() - parseInt(objLastRec[0]) + 3.6e+6);
    var totalSeconds = parseInt(Math.floor(deltaMs / 1000), 10);
    var totalMinutes = parseInt(Math.floor(totalSeconds / 60), 10);
    var seconds = parseInt(totalSeconds % 60, 10);
    var minutes = parseInt(totalMinutes % 60, 10);
    
    M.toast({html: `Dernière mise à jour : il y a ${ minutes == 0 ? '' : (minutes == 1 ? '1 minute et' : `${minutes} minutes et`)} ${seconds} secondes`});

    InitChar(objLastRec);
  }

  document.getElementById("loader").style.display = 'none';

  document.getElementById('btn_apply').classList.remove('disabled');

  bRunning = false;
}

var myChart = null;
function InitChar(_jsn) {
  if (myChart !== null)
    myChart.destroy();
  
  var ctx = document.getElementById('myChart').getContext('2d');

  var jsonRet = _jsn;

  const dateOpts = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit'};
  
  var tpNow = new Date();
  tpNow.setMinutes(0);
  var strNow = new Date(tpNow.getTime() - (tpNow.getTimezoneOffset() * 60000)).toISOString();
  strNow = `${strNow.slice(0, strNow.lastIndexOf(":"))}`;

  myChart = new Chart(ctx, {
      type: 'line',
      scaleShowValues: true,
      data: {
          labels: jsonRet[1]['hourly']['time'],
          datasets: [
          {
            label: 'Temperature',
            yAxisID: 'A',
            borderColor: 'rgba(0,0,0,0.5)',
            data: jsonRet[1]['hourly']['temperature_2m'],
            unit: '°C',
            fill: false,
            tension: 0.5,
            order: 0,
            pointBackgroundColor: function(context) {
              var index = context.dataIndex;
              var value = context.dataset.data[index];
              if (value >= 40) 
                return '#DD4740';
              else if (value >= 30) 
                return '#E1766F';
              else if (value >= 20) 
                return '#ED9F8D';
              else if (value >= 10) 
                return '#57C4F6';
              else if (value >= 0) 
                return '#1BABF3';
              else
                return '#208AF6';
            }
          },
          {
            label: 'Pluviometrie',
            yAxisID: 'B',
            backgroundColor: 'rgba(0,100,255,0.33)',
            data: jsonRet[1]['hourly']['precipitation'],
            unit: 'mm/h',
            order: 1
          },
          {
            label: 'Couverture nuageuse',
            yAxisID: 'C',
            backgroundColor: 'rgba(225,225,225,1)',
            data: jsonRet[1]['hourly']['cloudcover'],
            unit: '%',
            hidden: true,
            order: 3
          },
          {
            label: 'Vitesse du vent',
            yAxisID: 'D',
            backgroundColor: 'rgba(0,0,0,0.5)',
            data: jsonRet[1]['hourly']['windspeed_10m'],
            unit: 'km/h',
            hidden: true,
            order: 2
          },
          {
            label: 'Indice UV',
            yAxisID: 'E',
            backgroundColor: '#d616e0',
            data: jsonRet[2]['hourly']['uv_index'],
            unit: '',
            hidden: true,
            order: 4,
            fill: false,
            pointBackgroundColor: function(context) {
              var index = context.dataIndex;
              var value = context.dataset.data[index];
              if (value >= 11) 
              return 'rgb(107, 73, 200)';
              else if (value >= 8)
                return 'rgb(216, 0, 29)';
              else if (value >= 6)
                return 'rgb(248, 89, 0)';
              else if (value >= 3)
              return 'rgb(247, 228, 0)';
              else
              return 'rgb(78, 180, 0)';
            }
          },
          
          {
            label: 'Monoxyde de carbone',
            yAxisID: 'G',
            backgroundColor: 'rgba(50,0,0,0.5)',
            data: jsonRet[2]['hourly']['carbon_monoxide'],
            unit: '\u03BCg/m\u0033',
            hidden: true,
            order: 11
          },
          {
            label: 'Ozone',
            yAxisID: 'G',
            backgroundColor: 'rgba(160,0,0,0.5)',
            data: jsonRet[2]['hourly']['ozone'],
            unit: '\u03BCg/m\u0033',
            hidden: true,
            order: 10
          },
          {
            label: 'Poussière du Sahara',
            yAxisID: 'G',
            backgroundColor: 'rgba(150,0,0,0.5)',
            data: jsonRet[2]['hourly']['dust'],
            unit: '\u03BCg/m\u0033',
            hidden: true,
            order: 12
          },
          {
            label: 'PM 10',
            yAxisID: 'G',
            backgroundColor: 'rgba(200,0,0,0.5)',
            data: jsonRet[2]['hourly']['ozone'],
            unit: '\u03BCg/m\u0033',
            hidden: true,
            order: 13
          },
          {
            label: 'PM 2,5',
            yAxisID: 'G',
            backgroundColor: 'rgba(255,0,0,0.5)',
            data: jsonRet[2]['hourly']['dust'],
            unit: '\u03BCg/m\u0033',
            hidden: true,
            order: 14
          },          

          {
            label: "Pollen d'herbe",
            yAxisID: 'F',
            backgroundColor: 'rgba(0,42,0,0.5)',
            data: jsonRet[2]['hourly']['grass_pollen'],
            unit: 'Grains/m\u0033',
            hidden: true,
            order: 20
          },
          {
            label: 'Pollen de bouleau',
            yAxisID: 'F',
            backgroundColor: 'rgba(0,84,0,0.5)',
            data: jsonRet[2]['hourly']['birch_pollen'],
            unit: 'Grains/m\u0033',
            hidden: true,
            order: 21
          },
          {
            label: "Pollen d'aulne",
            yAxisID: 'F',
            backgroundColor: 'rgba(0,126,0,0.5)',
            data: jsonRet[2]['hourly']['alder_pollen'],
            unit: 'Grains/m\u0033',
            hidden: true,
            order: 22
          },
          {
            label: "Pollen d'armoise",
            yAxisID: 'F',
            backgroundColor: 'rgba(0,168,0,0.5)',
            data: jsonRet[2]['hourly']['mugwort_pollen'],
            unit: 'Grains/m\u0033',
            hidden: true,
            order: 23
          },
          {
            label: "Pollen d'olivier",
            yAxisID: 'F',
            backgroundColor: 'rgba(0,210,0,0.5)',
            data: jsonRet[2]['hourly']['olive_pollen'],
            unit: 'Grains/m\u0033',
            hidden: true,
            order: 24
          },
          {
            label: "Pollen d'ambroisie",
            yAxisID: 'F',
            backgroundColor: 'rgba(0,252,0,0.5)',
            data: jsonRet[2]['hourly']['ragweed_pollen'],
            unit: 'Grains/m\u0033',
            hidden: true,
            order: 25
          }
        ]
      },
      options: {
        responsive: true,
        interaction: {
          intersect: false,
          mode: 'index',
        },
        plugins: {
          annotation: {
            annotations: {
              line1: {
                type: 'line',
                xMin: strNow,
                xMax: strNow,
                borderColor: 'rgb(255, 99, 132)',
                borderWidth: 2,
              }
            }
          },
          tooltip: {
            enabled: false,
            external: function(context) {
                // Tooltip Element
                let tooltipEl = document.getElementById('chartjs-tooltip');

                // Create element on first render
                if (!tooltipEl) {
                    tooltipEl = document.createElement('div');
                    tooltipEl.id = 'chartjs-tooltip';
                    tooltipEl.innerHTML = '<table></table>';
                    tooltipEl.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    tooltipEl.style.color = 'rgba(255, 255, 255, 1.0)';
                    tooltipEl.style.padding = '20px';
                    tooltipEl.style.borderRadius = '20px';
                    document.body.appendChild(tooltipEl);
                }

                // Hide if no tooltip
                const tooltipModel = context.tooltip;
                if (tooltipModel.opacity === 0) {
                    tooltipEl.style.opacity = 0;
                    return;
                }

                // Set caret Position
                tooltipEl.classList.remove('above', 'below', 'no-transform');
                if (tooltipModel.yAlign) {
                    tooltipEl.classList.add(tooltipModel.yAlign);
                } else {
                    tooltipEl.classList.add('no-transform');
                }

                function getBody(bodyItem) {
                    return bodyItem.lines;
                }

                // Set Text
                if (tooltipModel.body) {
                    const titleLines = tooltipModel.title || [];
                    const bodyLines = tooltipModel.body.map(getBody);

                    let innerHtml = '<thead>';

                    titleLines.forEach(function(title) {
                        var dateTp = new Date(context['tooltip']['dataPoints'][0].label);
                        dateFormat = dateTp.toLocaleDateString('fr-FR', dateOpts);
                        dateFormat = dateFormat.charAt(0).toUpperCase() + dateFormat.slice(1);
                        innerHtml += '<tr><th>' + dateFormat + '</th></tr>';
                    });
                    innerHtml += '</thead>';
                    
                    let weatherIcn = '\uf075';
                    let weatherStr = '';
                    let indexID = parseInt(tooltipModel['$context']['tooltip']['dataPoints'][0]['dataIndex']);
                    let codIcon = parseInt(jsonRet[1]['hourly']['weathercode'][indexID]);
                    let IsDay = false;
                    let iIndexDay = Math.floor(indexID / 24);
                    if (new Date(jsonRet[1]['hourly']['time'][indexID]) > new Date(jsonRet[1]['daily']['sunrise'][iIndexDay])
                      && new Date(jsonRet[1]['hourly']['time'][indexID]) < new Date(jsonRet[1]['daily']['sunset'][iIndexDay]))
                      IsDay = true;
                    switch(codIcon) {
                      case  0: weatherStr = 'Ciel clair';                    weatherIcn = (IsDay ? '\uf00d' : '\uf02e'); break;
                      case  1: weatherStr = 'Principalement clair';          weatherIcn = (IsDay ? '\uf00c' : '\uf081'); break;
                      case  2: weatherStr = 'Partiellement nuageux';         weatherIcn = (IsDay ? '\uf002' : '\uf086'); break;
                      case  3: weatherStr = 'Ciel couvert';                  weatherIcn = '\uf041'; break;
                      case 45: weatherStr = 'Brouillard';                    weatherIcn = '\uf014'; break;
                      case 48: weatherStr = 'Brouillard givrant';            weatherIcn = '\uf014'; break;
                      case 51: weatherStr = 'Bruine (légère)';               weatherIcn = (IsDay ? '\uf00b' : '\uf039'); break;
                      case 56: weatherStr = 'Bruine verglaçante (légère)';   weatherIcn = (IsDay ? '\uf00b' : '\uf039'); break;
                      case 53: weatherStr = 'Bruine (modérée)';              weatherIcn = (IsDay ? '\uf00b' : '\uf039'); break;
                      case 55: weatherStr = 'Bruine (dense)';                weatherIcn = '\uf01c'; break;
                      case 57: weatherStr = 'Bruine verglaçante (dense)';    weatherIcn = (IsDay ? '\uf00b' : '\uf039'); break;
                      case 61: weatherStr = 'Pluie (légère)';                weatherIcn = (IsDay ? '\uf009' : '\uf029'); break;
                      case 66: weatherStr = 'Pluie verglaçante (légère)';    weatherIcn = (IsDay ? '\uf009' : '\uf029'); break;
                      case 63: weatherStr = 'Pluie (modérée)';               weatherIcn = '\uf01a'; break;
                      case 65: weatherStr = 'Pluie (forte)';                 weatherIcn = '\uf019'; break;
                      case 67: weatherStr = 'Pluie verglaçante (forte)';     weatherIcn = '\uf01a'; break;
                      case 71: weatherStr = 'Chute de neige (légère)';       weatherIcn = (IsDay ? '\uf0b2' : '\uf0b4'); break;
                      case 73: weatherStr = 'Chute de neige (modérée)';      weatherIcn = (IsDay ? '\uf00a' : '\uf02a'); break;
                      case 75: weatherStr = 'Chute de neige (forte)';        weatherIcn = '\uf01b'; break;
                      case 80: weatherStr = 'Averses de pluie (légères)';    weatherIcn = (IsDay ? '\uf009' : '\uf029'); break;
                      case 81: weatherStr = 'Averses de pluie (modérées)';   weatherIcn = (IsDay ? '\uf006' : '\uf026'); break;
                      case 82: weatherStr = 'Averses de pluie (violentes)';  weatherIcn = (IsDay ? '\uf008' : '\uf028'); break;
                      case 85: weatherStr = 'Averses de neige (légères)';    weatherIcn = (IsDay ? '\uf00a' : '\uf02a'); break;
                      case 86: weatherStr = 'Averses de neige (fortes)';     weatherIcn = '\uf01b'; break;
                      case 77: weatherStr = 'Neige en grains';               weatherIcn = (IsDay ? '\uf004' : '\uf024'); break;
                      case 95: weatherStr = 'Orage (léger ou modéré)';       weatherIcn = '\uf01e'; break;
                      case 96: weatherStr = 'Orage (grêle légère)';          weatherIcn = (IsDay ? '\uf068' : '\uf06a'); break;
                      case 99: weatherStr = 'Orage (grêle forte)';           weatherIcn = '\uf01d'; break;
                    }
                    innerHtml += `<div style="margin:15px 15px 15px 0px;font-size:15px;">${weatherStr}</div>`;
                    innerHtml += `<div style="display:inline;"><div style="display:inline-block;margin-right:35px;font-family:weathericons;font-size:50px;vertical-align:top;">${weatherIcn}</div>`;
                    innerHtml += '<tbody style="display:inline;vertical-align:top;">';
                    bodyLines.forEach(function(body, i) {
                        const colors = tooltipModel.labelColors[i];
                        const squareIndicator = `<div style="background-color:${colors.backgroundColor};width:10px;height:10px;display:inline-block;margin-right:5px;"></div>`;
                        let style = 'color: white;';
                        const span = '<span style="' + style + '">' + body + ' ' + tooltipModel['$context']['tooltip']['dataPoints'][i]['dataset']['unit'] + '</span>';
                        innerHtml += '<tr><td>' + squareIndicator + span + '</td></tr>';
                    });
                    innerHtml += '</tbody>';
                    innerHtml += `<div style="font-size:15px;font-family:weathericons;color:#EEAF61;">\uf051 ${jsonRet[1]['daily']['sunrise'][iIndexDay].substr(11)}</div>`;
                    innerHtml += `<div style="font-size:15px;font-family:weathericons;color:#CE4993;">\uf052 ${jsonRet[1]['daily']['sunset'][iIndexDay].substr(11)}</div>`;
                    innerHtml += '</div>';

                    let tableRoot = tooltipEl.querySelector('table');
                    tableRoot.innerHTML = innerHtml;
                }

                const position = context.chart.canvas.getBoundingClientRect();
                const bodyFont = Chart.helpers.toFont(tooltipModel.options.bodyFont);

                // Display, position, and set styles for font
                tooltipEl.style.opacity = 1;
                tooltipEl.style.position = 'absolute';
                tooltipEl.style.left = position.left + window.pageXOffset + tooltipModel.caretX + 'px';
                tooltipEl.style.top = position.top + window.pageYOffset + tooltipModel.caretY + 'px';
                tooltipEl.style.font = bodyFont.string;
                tooltipEl.style.padding = tooltipModel.padding + 'px ' + tooltipModel.padding + 'px';
                tooltipEl.style.pointerEvents = 'none';
            }
          },
          legend: {
            labels: {
              usePointStyle: true,
              filter: function(item, chart) {
                return !chart.datasets[item.datasetIndex]['data'].every((val, i, arr) => val === null);
              }
            }
          }
        },
        scales: {
          xAxis: {
            ticks: {
              autoSkip: false,
              maxRotation: 0,
              minRotation: 0,
              callback: function(value, index) {
                if (index % 24 === 12) {
                  const event = new Date(this.getLabelForValue(value));
                  let strLine = event.toLocaleDateString('fr-FR', dateOpts)
                  let strDate = strLine.substr(0, strLine.indexOf('à') - 1);
                  return strDate.charAt(0).toUpperCase() + strDate.slice(1);

                }
                else
                  return '';
              }
            },
            grid: {
              color: (context) => {
                return context.index % 24 === 0 ? 'rgba(0, 0, 0, 0.2)' : 'rgba(0, 0, 0, 0)';
              },
              lineWidth: 2
            }
          },
          A: {
            type: 'linear',
            position: 'left',
            min: -5,
            max: 45,
            title: {
              display: true,
              text: 'Temperature (°C)'
            }
          },
          B: {
            type: 'linear',
            position: 'right',
            min: 0,
            max: 10,
            title: {
              display: false,
              text: 'Pluviometrie (mm/h)'
            },
            grid : {
              display: false
            },
            display: false
          },
          C: {
            type: 'linear',
            position: 'right',
            min: 0,
            max: 100,
            title: {
              display: false,
              text: 'Couverture nuageuse (%)'
            },
            grid : {
              display: false
            },
            display: false
          },
          D: {
            type: 'linear',
            position: 'right',
            min: 0,
            max: 120,
            title: {
              display: false,
              text: 'Vitesse du vent (km/h)'
            },
            grid : {
              display: false
            },
            display: false
          },
          E: {
            type: 'linear',
            position: 'right',
            min: 0,
            max: 11,
            title: {
              display: false,
              text: 'Indice UV'
            },
            grid : {
              display: false
            },
            display: false
          },
          F: {
            type: 'linear',
            position: 'right',
            min: 0,
            max: 400,
            title: {
              display: false,
              text: 'Pollen (Grains/m\u0033)'
            },
            grid : {
              display: false
            },
            display: false
          },
          G: {
            type: 'linear',
            position: 'right',
            min: 0,
            max: 600,
            title: {
              display: false,
              text: 'Particules (\u03BCg/m\u0033)'
            },
            grid : {
              display: false
            },
            display: false
          }
        }
      }
  });
}
</script>
